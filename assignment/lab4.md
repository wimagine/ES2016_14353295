## lab4 死锁 ##

理解死锁产生条件

### 实验步骤 ###

1. 在windows下编译Deadlock.java文件。

1. 将.bat文件放到刚编译完的Deadlock.class文件路径下，并双击.bat文件，查看实验效果。

### 实验结果 ###

如图，在第51次产生死锁。

![](http://i.imgur.com/ZHJdvMN.png)

### 实验分析 ###

####总结：死锁产生的4个必要条件####

1.  互斥条件：一个资源每次只能被一个进程使用。
2.  占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3.  不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4.  循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
四个条件只有同时满足时才能造成死锁，打破任意一个条件就不会死锁。

这4个条件在代码中的具体体现：

首先在代码中的MethodA、MethodB和last函数都是synchronized，当函数被它修饰时，能够保证在同一时刻最多只有一个线程执行该代码；同时需要注意的是当一个线程访问对象的一个synchronized代码块或方法时，其他线程对对象中所有其他synchronized代码块或同步方法的访问会被阻塞。

因此，由于run函数是在主线程中一直跑的，它不停的交替调用classB的methodB方法和ClassaA的last方法；因为两个方法都是synchronized，所以classB和ClassA会被交替的阻塞；count时间后，a.methodA(b)被调用，需要先后访问ClassA的methodA和ClassB的last方法，如果恰好碰上此时ClassA或ClassB被主线程阻塞，就会死锁。

实验过程中，现在ubuntu中测试，发现无论如何修改count值，都不会死锁；而在windows下测试就100%死锁；猜想可能是ubuntu底层没跑什么程序，因此运行速度很快，不容易死锁。
